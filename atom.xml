<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Siberiawind的博客</title>
  
  <subtitle>不积跬步，无以至千里</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-21T23:48:30.709Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Siberia怒风</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>c的编译过程链</title>
    <link href="http://yoursite.com/2020/08/22/c%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2020/08/22/c%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E9%93%BE/</id>
    <published>2020-08-21T23:46:18.000Z</published>
    <updated>2020-08-21T23:48:30.709Z</updated>
    
    <content type="html"><![CDATA[<p>编译，是一个逐步的过程，编译的最终输出是在某个特定平台(x86_64或者armv7_64)上运行的可执行文件<br>（x86_64 armv7的区别）</p><p>编译过程链如下：</p><p>源代码:rightarrow:预处理:rightarrow:编译:rightarrow:汇编:rightarrow:链接:rightarrow:可执行文件</p><p>以<code>main.c</code>为例<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一般情况下，无论是直接在命令行还是在Makefile中，我们都用的是<code>gcc main.c</code>来进行编译工作</p><p>而该句话省略了大部分的编译过程链，其大致等价于以下几句命令的组合：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -E main.c &gt; main.i          //对源文件中使用到的宏进行扩展，生成原始的c文件</span><br><span class="line">gcc -S main.i                   //将上一步得到的原始c文件编译生成汇编代码</span><br><span class="line">gcc -c main.s                   //调用汇编器将汇编代码转换为目标代码</span><br><span class="line">gcc main.s -o main              //链接器解析外部函数的地址，最后结合目标文件生成一个可执行文件</span><br><span class="line">rm main.c main.s</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;编译，是一个逐步的过程，编译的最终输出是在某个特定平台(x86_64或者armv7_64)上运行的可执行文件&lt;br&gt;（x86_64 armv7的区别）&lt;/p&gt;
&lt;p&gt;编译过程链如下：&lt;/p&gt;
&lt;p&gt;源代码:rightarrow:预处理:rightarrow:编译:right</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>FFmpeg初识</title>
    <link href="http://yoursite.com/2020/08/21/FFmpeg%E5%88%9D%E8%AF%86/"/>
    <id>http://yoursite.com/2020/08/21/FFmpeg%E5%88%9D%E8%AF%86/</id>
    <published>2020-08-21T00:02:26.000Z</published>
    <updated>2020-08-21T00:11:45.477Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-制作ScreenMaps"><a href="#1-制作ScreenMaps" class="headerlink" title="1. 制作ScreenMaps"></a>1. 制作ScreenMaps</h2><p><a href="http://dranger.com/ffmpeg/tutorial01.html">原文地址</a></p><p>文件本身是个容器</p><p>不同容器的种类决定了文件内的信息</p><p>常见的容器格式有AVI、Quicktime</p><p>在一个容器内，我们可以封装很多的流</p><p>常见的，我们都会有一个音频流和一个视频流</p><p>流内的元素我们称之为序列</p><p>每一条流都有其特定的编码格式，对应特定的codec编码解码器</p><p>codec决定了实际的数据如何被COded，如何被DECoded，这也是其名字CODEC的由来</p><p>常见的codec有DivX以及MP3</p><p>包Packets 是每次从流中读取得到的数据块，其内包含有我们最终需要输入应用中的信息</p><p>常见的视频流处理流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 从video.avi容器内打开video视频流</span><br><span class="line">2. 从video视频流中源源不断的读取packet到frame内</span><br><span class="line">3. 如果frame是不完整的，那么继续回到2</span><br><span class="line">4. 对frame进行相应的处理</span><br><span class="line">5. 返回2</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ffmpeg/swscale.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    av_register_all();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>av_register_all()将会在程序运行时对所有可用的codec以及format进行登记，一般来说，没有必要指定登记某一种codec或者format，且由于只需要登记一次，<br>我们也只需要在main()函数中调用一次即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AVFormatContext* pFormatCtx = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// Open Video file</span></span><br><span class="line"><span class="keyword">if</span>(avformat_open_input(&amp;pFormatCtx, argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>)!=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// Return -1 if open input failed</span></span><br></pre></td></tr></table></figure><p>avformat_open_input()函数将读取文件的头，并在AVFormatContext结构体变量pFormatCtx中存储相应的文件信息，其后三个参数分别对应的是 文件格式，缓冲<br>区大小以及格式选项，分别设置为NULL或者0可以令libavformat库自动检测这些</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// retrieve stream information</span></span><br><span class="line"><span class="keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// Return -1 if find stream information failed</span></span><br></pre></td></tr></table></figure><p>avformat_find_stream_info()函数将检查pFormatCtx变量内的流信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dump infomation about file onto standard error</span></span><br><span class="line">av_dump_format(pFormatCtx, <span class="number">0</span>, argv[<span class="number">1</span>], <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>pFormatCtx-&gt;streams只是一个指针数组，其大小为pFormatCtx-&gt;nb_streams，遍历该指针数组直到我们找到一个videoStream<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">AVCodecContext* pCodecCtxOrig = <span class="literal">NULL</span>;</span><br><span class="line">AVCodecContext* pCodecCtx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find the first video stream</span></span><br><span class="line"><span class="keyword">int</span> videoStream = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; pFormatCtx-&gt;nb_streams; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO)</span><br><span class="line">    &#123;</span><br><span class="line">        videoStream = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(videoStream == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// Failed to find a video stream</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get a pointer to the codec context for the video stream</span></span><br><span class="line">pCodecCtx = pFormatCtx-&gt;streams[videoStream]-&gt;codec;</span><br></pre></td></tr></table></figure></p><p>流内有关codec编解码器的信息我们称之为’codec context’编解码上下文，它包含了当前流使用的codec所有的信息，然后我们用一个指针指向它</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">AVCodec* pCodec = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// Find the decoder for the video stream</span></span><br><span class="line">pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id);</span><br><span class="line"><span class="keyword">if</span>(pCodec == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unsupported codec!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy Context</span></span><br><span class="line">pCodecCtx = avcodec_alloc_context3(pCodec);</span><br><span class="line"><span class="comment">// avcodec_copy_context(target, src)，因为不能直接使用视频流内的codec上下文，我们需要将其拷贝出来到我们刚初始化的pCodecCtx 这个codec上下文中</span></span><br><span class="line"><span class="keyword">if</span>(avcodec_copy_context(pCodecCtx, pCodecCtxOrig)!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Couldn&#x27;t copy codec context&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// Error while copying codec context</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Open codec</span></span><br><span class="line"><span class="keyword">if</span>(avcodec_open2(pCodecCtx, pCodec) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再定义一段内存用来存放packet流内的frame信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AVFrame* pFrame = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// Allocate video frame;</span></span><br><span class="line">pFrame = av_frame_alloc();</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate an AVFrame structure</span></span><br><span class="line">pFrameRGB = av_frame_alloc();</span><br><span class="line"><span class="keyword">if</span>(pFrameRGB == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> *<span class="built_in">buffer</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> numBytes;</span><br><span class="line"><span class="comment">// Determine required buffer size and allocate buffer</span></span><br><span class="line"><span class="comment">// 24 bits(3 bytes) x width x height</span></span><br><span class="line">numBytes = avpicture_get_size(PIX_FMT_RGB24, pCodecCtx-&gt;<span class="built_in">width</span>, pCodecCtx-&gt;<span class="built_in">height</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">buffer</span> = (<span class="keyword">uint8_t</span>*)av_malloc(numBytes * <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br></pre></td></tr></table></figure><p>此处的av_malloc是原malloc的一个简单包装器，它只能确保内存地址是对齐的，但它仍无法防止一些内存泄露，double free以及其它的malloc常见问题</p><p>接下来要用avpicture_fill来将帧填充到新分配的缓冲区中，AVPicture是AVFrame结构体的子集</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assign appropriate parts of buffer to image planesin pFrameRGB</span></span><br><span class="line"><span class="comment">// Note that pFrameRGB is an AVFrame, but AVFrame is a superset of AVPicture</span></span><br><span class="line">avpicture_fill((AVPicture *) pFrameRGB, <span class="built_in">buffer</span>, PIX_FMT_RGB24, pCodecCtx-&gt;<span class="built_in">width</span>, pCodecCtx-&gt;<span class="built_in">height</span>);</span><br></pre></td></tr></table></figure><p><strong>读取数据</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SwsContext</span> *<span class="title">sws_ctx</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="keyword">int</span> frameFinished;</span><br><span class="line">AVPacket packet;</span><br><span class="line"><span class="comment">// initialize SWS context for software scaling</span></span><br><span class="line">sws_ctx = sws_getContext(pCodecCtx-&gt;<span class="built_in">width</span>,</span><br><span class="line">                                pCodecCtx-&gt;<span class="built_in">height</span>,</span><br><span class="line">                                pCodecCtx-&gt;pix_fmt,</span><br><span class="line">                                pCodecCtx-&gt;weight,</span><br><span class="line">                                pCodecCtx-&gt;<span class="built_in">height</span>,</span><br><span class="line">                                PIX_FMT_RGB24,</span><br><span class="line">                                SWS_BILINEAR,</span><br><span class="line">                                <span class="literal">NULL</span>,</span><br><span class="line">                                <span class="literal">NULL</span>,</span><br><span class="line">                                <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(av_read_frame(pFormatCtx, &amp;packet) &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判定该packet是否是video stream的packet</span></span><br><span class="line">    <span class="keyword">if</span>(packet.stream_index == videoStream)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Decode video frame</span></span><br><span class="line">        avcodec_decode_video2(pCodecCtx, pFrame, &amp;frameFinished, &amp;packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Did we get a video frame?</span></span><br><span class="line">        <span class="keyword">if</span>(frameFinished)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Convert the image from its native format to RGB</span></span><br><span class="line">            sws_scale(sws_ctx, (<span class="keyword">uint8_t</span> <span class="keyword">const</span> * <span class="keyword">const</span> *)pFrame-&gt;data, pFrame-&gt;linesize, <span class="number">0</span>, pCodecCtx-&gt;<span class="built_in">height</span>, pFrameRGB-&gt;data, pFrameRGB-&gt;linesize);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// save the frame to disk</span></span><br><span class="line">            <span class="keyword">if</span>(++i &lt;= <span class="number">5</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                SaveFrame(pFrameRGB, pCodecCtx-&gt;<span class="built_in">width</span>, pCodecCtx-&gt;<span class="built_in">height</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Free the packet that was allocated by av_read_frame</span></span><br><span class="line">    av_free_packet(&amp;packet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SaveFrame()函数是我们定义的图像写入函数，下面将帧写入到ppm文件中，有关ppm格式的相关介绍可参考:arrow_right:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SaveFrame</span><span class="params">(AVFrame *pFrame, <span class="keyword">int</span> <span class="built_in">width</span>, <span class="keyword">int</span> <span class="built_in">height</span>, <span class="keyword">int</span> iFrame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *pFile;</span><br><span class="line">    <span class="keyword">char</span> szFileName[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open file</span></span><br><span class="line">    <span class="built_in">sprintf</span>(szFileName, <span class="string">&quot;frame%d.ppm&quot;</span>, iFrame);</span><br><span class="line">    pFile = fopen(szFileName, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(pFile == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write header</span></span><br><span class="line">    <span class="built_in">fprintf</span>(pFile, <span class="string">&quot;P6\n%d %d\n255\n&quot;</span>, <span class="built_in">width</span>, <span class="built_in">height</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write pixel data</span></span><br><span class="line">    <span class="keyword">for</span>(y=<span class="number">0</span>; y&lt;<span class="built_in">height</span>; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        fwrite(pFrame-&gt;data[<span class="number">0</span>] + y*pFrame-&gt;linesize[<span class="number">0</span>], <span class="number">1</span>, <span class="built_in">width</span>*<span class="number">3</span>, pFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// close file</span></span><br><span class="line">    fclose(pFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PPM图像就是一个将原有RGB信息以字符串形式平铺开来的文件，其头文件会包含图像的宽和高大小，以及RGB值的最大值。当完成video stream的读取操作后，清<br>除everything</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free the RGB image</span></span><br><span class="line">av_free(<span class="built_in">buffer</span>);</span><br><span class="line">av_free(pFrameRGB);</span><br><span class="line"><span class="comment">// Free the YUV frame</span></span><br><span class="line">av_free(pFrame);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close the codecs</span></span><br><span class="line">avcodec_close(pCodecCtx);</span><br><span class="line">avcodec_close(pCodecCtxOrig);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close the video file</span></span><br><span class="line">avformat_close_input(&amp;pFormatCtx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>下面，上gcc编译命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc tutorial1.c -o tutorial -lavutil -lavformat -lavcodec -lz -lm</span><br></pre></td></tr></table></figure><h2 id="2-投影到屏幕上-Output-to-the-screen"><a href="#2-投影到屏幕上-Output-to-the-screen" class="headerlink" title="2. 投影到屏幕上 Output to the screen"></a>2. 投影到屏幕上 Output to the screen</h2><p>为了将pixel绘制(draw)到屏幕上，我们需要用到SDL库（现在用的是SDL2.0库）</p><p>SDL就是Simple Direct Layer，是一个跨平台的多媒体库</p><p>YUV是一种存储raw image数据的方式，Y是brightness亮度组件，U和V是颜色组件。SDL库中有一种叫做YUV overlay的方法可以将movies放映到screen上，该方法<br>仅需输入YUV data作为raw数组即可display它，它接受4种YUV形式，其中YV12是最快的，YUV420P与YV12速度差不多，只是U和V的顺序被替换了。YUV420P中420指<br>代下采样的比例是4:2:0</p><p>首先，我们需要初始化SDL，SDL_Init()函数会告诉函数库将会使用哪些特性:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not initialize SDL - %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们需要在屏幕上定义一块区域来放置我们的stuff，SDL1.0库中用的是SDL_Surface，SDL2.0库中用的是SDL_Window：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SDL_Window *screen;</span><br><span class="line">screen = SDL_CreateWindow(<span class="string">&quot;FFmpeg play&quot;</span>,</span><br><span class="line">                                    SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                                    SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                                    pCodecCtx-&gt;width,</span><br><span class="line">                                    pCodecCtx-&gt;height,</span><br><span class="line">                                    <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(!screen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;SDL: Could not create window!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-制作ScreenMaps&quot;&gt;&lt;a href=&quot;#1-制作ScreenMaps&quot; class=&quot;headerlink&quot; title=&quot;1. 制作ScreenMaps&quot;&gt;&lt;/a&gt;1. 制作ScreenMaps&lt;/h2&gt;&lt;p&gt;&lt;a href</summary>
      
    
    
    
    
  </entry>
  
</feed>
